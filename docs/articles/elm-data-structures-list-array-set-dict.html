<!DOCTYPE html><head><title>Viktor Břenek</title><meta content="text/html;charset=utf-8" http-equiv="Content-Type"><meta content="utf-8" http-equiv="encoding"><meta name="author" content="Petr Břenek"><meta name="description" content="Osobní blog a portfolio"><meta property="og:image" content="http://viktorbrenek.github.io/assets/images/modely.png"><meta name="viewport" content="width=device-width,initial-scale=1.0"><link rel="stylesheet" href="../styles.css"><meta charset="utf-8"><title>Blog</title></head><body><ul class="links" id="links"> <li><a class="who" href="https://discord.com/invite/2Uj6N5N" target="_blank">Discord</a></li><li><a class="blog" href="https://www.youtube.com/c/ViktorBřenekYT" target="_blank">Youtube</a></li><li><a class="source" href="https://github.com/viktorbrenek" target="_blank">Github</a></li></ul><menu><a class="name" href="#">Viktor Břenek</a><a class="name" href="../blog.html">Blog</a><a class="name" href="../index.html">Portfolio</a></menu><main class="gridblog"><h1 class="atitle">Elm Data Structures (1)</h1><div><span><ul class="task__tags"><li class="task__tag task__tag--copyright">Elm</li><li class="task__tag task__tag--copyright">Frontend development</li><li class="task__tag task__tag--copyright">Data structures</li><li class="task__tag task__tag--copyright">List</li><li class="task__tag task__tag--copyright">Array</li><li class="task__tag task__tag--copyright">Set</li><li class="task__tag task__tag--copyright">Dict</li></ul></span></div><p>In Elm there are different kinds of data structures that can contain elements. This article spotlights the iterable structures lists, arrays, sets and dictionaries, which support the basic operations of functional programming like <code>map</code>, <code>filter</code> and folding/reducing.</p>
<div id="more"></div>
<p>All of these data structures require that the elements they contain have the same type – e.g. a list of strings: <code>List String</code>. The compiler takes care of enforcing the type safety, which is a difference to JavaScript, where arrays can contain elements of any type.</p>
<p>The different data structures share a common “interface” of functions, which can be used to iterate over the elements and operate on them. Besides the basic operations <code>map</code>, <code>filter</code>, <code>foldl</code>/<code>foldr</code> (know to the JavaScripter as <code>reduce</code>) there are also functions like <code>isEmpty</code> or <code>member</code>. The latter is not available for arrays though, which brings us right to the differences and use cases of the different kinds of data structures …</p>
<h3>Lists</h3>
<p>Lists are the essential and most used data structure in Elm. There are several ways to create a list: <em>(as shown in the previous article about <a href="elm-functions.html">functions</a> you can use the REPL to run the code samples.)</em></p>
<pre><code class="language-elm"><span class="hljs-title">list</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
<span class="hljs-title">listFromRange</span> = [<span class="hljs-number">1.</span><span class="hljs-number">.4</span>]
<span class="hljs-title">listByAppending</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] ++ [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
<span class="hljs-title">listByPrepending</span> = <span class="hljs-number">1</span> :: <span class="hljs-number">2</span> :: <span class="hljs-number">3</span> :: <span class="hljs-number">4</span> :: []

<span class="hljs-comment">-- [1,2,3,4] : List number</span>
</code></pre>
<p>The list syntax resembles JavaScript arrays, but the big difference to an array is that lists in Elm do not support accessing elements by index – at least not in its standard library version. Of course this functionality can be implemented and already exists in the <a href="http://package.elm-lang.org/packages/circuithub/elm-list-extra/3.9.0/List-Extra">List-Extra</a> community package. Nevertheless this use case is pretty rare when operating on lists in a functional way. Instead you will be using functions like <code>filter</code>, <code>head</code> und <code>tail</code> to select certain elements or parts of a list:</p>
<pre><code class="language-elm"><span class="hljs-title">list</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
<span class="hljs-comment">-- [1,2,3,4] : List number</span>

<span class="hljs-title">filteredList</span> = <span class="hljs-type">List</span>.filter (\n -&gt; n &gt; <span class="hljs-number">2</span>) list
<span class="hljs-comment">-- [3,4] : List number</span>

<span class="hljs-title">firstElement</span> = <span class="hljs-type">List</span>.head list
<span class="hljs-comment">-- Just 1 : Maybe.Maybe number</span>

<span class="hljs-title">restOfTheElements</span> = <span class="hljs-type">List</span>.tail list
<span class="hljs-comment">-- Just [2,3,4] : Maybe.Maybe (List number)</span>
</code></pre>
<p>All of the transforming functions like <code>filter</code>, <code>concat</code>, or <code>take</code> return new instances as data in Elm is immutable. Some functions like <code>head</code> and <code>tail</code> do not return a new instance of a list directly, but an instance of <code>Maybe</code> which might contain the list. This is due to the fact that Elm does not have values like <code>null</code> or <code>undefined</code> – however there must be a return value for cases like empty lists. As this is a topic on its own we will take a closer look at the type <code>Maybe</code> in a future article.</p>
<p>For an overview of all available list functions see the documentation of the <a href="http://package.elm-lang.org/packages/elm-lang/core/3.0.0/List">List</a> module.</p>
<h3>Arrays</h3>
<p>As already mentioned an <a href="http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Array">Array</a> supports positional access to its elements via the index. Arrays are 0-based, like in JavaScript. As opposed to lists, arrays also support setting elements via the index:</p>
<pre><code class="language-elm"><span class="hljs-title">array</span> = <span class="hljs-type">Array</span>.fromList [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
<span class="hljs-comment">-- Array.fromList [1,2,3,4] : Array.Array number</span>

<span class="hljs-title">thirdElement</span> = <span class="hljs-type">Array</span>.get <span class="hljs-number">2</span> array
<span class="hljs-comment">-- Just 3 : Maybe.Maybe number</span>

<span class="hljs-title">sliceOfArray</span> = <span class="hljs-type">Array</span>.slice <span class="hljs-number">1</span> <span class="hljs-number">3</span> array
<span class="hljs-comment">-- Array.fromList [2,3] : Array.Array number</span>

<span class="hljs-title">modifiedArray</span> = <span class="hljs-type">Array</span>.set <span class="hljs-number">2</span> <span class="hljs-number">7</span> array
<span class="hljs-comment">-- Array.fromList [1,2,7,4] : Array.Array number</span>
</code></pre>
<p>The possibility to work with elements based on the index offers performance gains for use cases like targeted access and replacing of elements. The implementation of <a href="http://elm-lang.org/blog/announce/0.12.1">arrays as Relaxed Radix Balanced Trees</a> makes accessing and modification of elements and parts of an array very fast, especially when dealing with large arrays.</p>
<p>Nevertheless arrays – as well as sets and dictionaries – are kind of second class data structures in Elm. This due to the fact that a majority of use cases can be modeled easily with lists and that there is <a href="https://github.com/elm-lang/elm-plans/issues/12">no literal syntax</a> for these data structures. The latter makes dealing with them kind of clunky as they cannot be instantiated with syntactical shortcuts. This also makes arrays, sets and dictionaries not as well suited for domain-specific languages like elm-html.</p>
<h3>Sets</h3>
<p>A <a href="http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Set">Set</a> guarantees a collection of unique values. This means that a set can never contain multiple elements with the same value – therefore there is no need to filter out duplicates from a set.</p>
<pre><code class="language-elm"><span class="hljs-keyword">import</span> Set

<span class="hljs-title">set1</span> = <span class="hljs-type">Set</span>.fromList [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
<span class="hljs-comment">-- Set.fromList [1,2,3,4] : Set.Set number</span>

<span class="hljs-title">set2</span> = <span class="hljs-type">Set</span>.fromList [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]
<span class="hljs-comment">-- Set.fromList [3,4,5,6] : Set.Set number</span>

<span class="hljs-title">intersection</span> = <span class="hljs-type">Set</span>.intersect set1 set2
<span class="hljs-comment">-- Set.fromList [3,4] : Set.Set number</span>

<span class="hljs-title">union</span> = <span class="hljs-type">Set</span>.union set1 set2
<span class="hljs-comment">-- Set.fromList [1,2,3,4,5,6] : Set.Set number</span>

<span class="hljs-title">differences</span> = <span class="hljs-type">Set</span>.diff set1 set2
<span class="hljs-comment">-- Set.fromList [1,2] : Set.Set number</span>
</code></pre>
<p>Sets are well suited for operations in which one need to find intersections, unions, or differences of two sets.</p>
<h3>Dictionaries</h3>
<p>The data structure <a href="http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Dict"><code>Dict</code></a> stores key-value pairs. The keys are unique and can be of any comparable datatype value, so that besides <code>String</code> and <code>Int</code> also values of the types <code>Float</code> and <code>Time</code> can be used as keys.
The values in a dictionary can be of any type as long as all of them have the same type (which is the requirement for all data structure in Elm).</p>
<p>A possible type for values is a record, which we will use in the following example and take a closer look at in the upcoming article about tuples and records:</p>
<pre><code class="language-elm"><span class="hljs-keyword">import</span> Dict

<span class="hljs-title">users</span> = <span class="hljs-type">Dict</span>.fromList \
    [ (<span class="hljs-string">"dennis"</span>, { email = <span class="hljs-string">"mail@dennisreimann.de"</span>}) \
    , (<span class="hljs-string">"otherdude"</span>, { email = <span class="hljs-string">"otherdude@example.org"</span>}) \
    ]

<span class="hljs-title">usernames</span> = <span class="hljs-type">Dict</span>.keys users
<span class="hljs-comment">-- ["dennis","otherdude"] : List String</span>

<span class="hljs-title">userRecords</span> = <span class="hljs-type">Dict</span>.values users
<span class="hljs-comment">-- [{ email = "mail@dennisreimann.de" },{ email = "otherdude@example.org" }] : List { email : String }</span>

<span class="hljs-title">dennis</span> = <span class="hljs-type">Dict</span>.get <span class="hljs-string">"dennis"</span> users
<span class="hljs-comment">-- Just { email = "mail@dennisreimann.de " } : Maybe.Maybe { email : String }</span>
</code></pre>
<p>The next article covers the data structures <a href="/articles/elm-data-structures-record-tuple.html">record and tuple</a>, which can contain elements of different types.</p>
</main><footer></footer></body>