<!DOCTYPE html><head><title>Viktor Břenek</title><meta content="text/html;charset=utf-8" http-equiv="Content-Type"><meta content="utf-8" http-equiv="encoding"><meta name="author" content="Petr Břenek"><meta name="description" content="Osobní blog a portfolio"><meta property="og:image" content="http://viktorbrenek.github.io/assets/images/modely.png"><meta name="viewport" content="width=device-width,initial-scale=1.0"><style>@import url('https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap');

body {
  background-color: #3d3f41;
  font-family: "Lato", sans-serif;
  color: #c7c7b0;
}
.mainpage {
  display: block;
}
h1 {
  display: block;
  font-size: 4.5rem;
  margin-block-start: 0.67em;

  margin-inline-start: 0px;
  margin-inline-end: 0px;
  font-weight: bold;
}
.links {
  position: fixed;
  list-style: none;
  width: 120px;
  bottom: 40px;
  right: 20px;
  padding: 0;
  margin: 0;
  z-index: 998;
}
.links p {
  font-family: "Lato", sans-serif;
  text-transform: uppercase;
  text-align: center;
  padding: 0.25em 0;
  letter-spacing: 2px;
  font-size: 10px;
  display: block;
  width: 100%;
  opacity: 0.6;
  color: #FFF;
}
.links li {
  border-bottom: #222 1px solid;
  border-bottom: rgba(255, 255, 255, 0.1) 1px solid;
}
.links li a {
  transition: opacity 0.2s ease-out;
  font-family: "Lato", sans-serif;
  text-transform: uppercase;
  text-align: right;
  padding: 0.25em 0;
  letter-spacing: 2px;
  font-size: 12px;
  display: block;
  width: 100%;
  opacity: 0.4;
  color: #FFF;
}
.links li a:hover {
  opacity: 0.8;
}
.links li .who:before {
  opacity: 0.5;
  content: '@';
  float: left;
}
.links li .source:before {
  opacity: 0.5;
  content: '{}';
  float: left;
}
.links li .blog:before {
  opacity: 0.5;
  content: '&';
  float: left;
}
.hide {
  opacity: 0;
}
*,
*::before,
*::after {
  -webkit-box-sizing: border-box;
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
:root {
  font-size: 10px;
  --padding: 3rem;
}
::-moz-selection {
  background: #111111;
  color: #595959;
}
::selection {
  background: #111111;
  color: #595959;
}
html {
  font-family: "Lato", sans-serif;
}
@supports (font-variation-settings: normal) {
  html {
    font-family: "Lato", sans-serif;
  }
}
h1,
h2,
h3,
h4,
p,
a,
span {
  text-rendering: geometricPrecision;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
h1 {
  font-size: 4.5rem;
  line-height: 1.3;
}
a {
  text-decoration: none;
  color: white;
  -webkit-filter: brightness(0.8);
  filter: brightness(0.8);
  -webkit-transition: 150ms;
  -o-transition: 150ms;
  transition: 150ms;
}
a,
a * {
  border-radius: 0.15rem;
}
a:hover {
  -webkit-filter: brightness(1.09);
  filter: brightness(1.09);
}
menu {
  justify-content: space-between;
  position: fixed;
  width: 100%;
  top: 0;
  overflow: auto;
  background-color: rgba(0, 0, 0, 0.750);
  z-index: 999;
}
menu a {
  font-size: 2.2rem;
  color: white;
  text-align: center;
  display: block;
  float: left;
  padding: 16px 14px;
  text-decoration: none;
}
.grid {
  display: -ms-grid;
  display: grid;
  -ms-grid-columns: 1fr 1.5rem 1fr 1.5rem 1fr 1.5rem 1fr 1.5rem 1fr 1.5rem 1fr;
  grid-template-columns: repeat(6, 1fr);
  grid-row-gap: 1.5rem;
  grid-column-gap: 1.5rem;
  margin: 0 auto;
  max-width: 150rem;
}
body {
  background: #1a1a1a;
  color: white;
}
.gridblog {
  grid-template-columns: repeat(6, 1fr);
  grid-row-gap: 1.5rem;
  grid-column-gap: 1.5rem;
  margin: 0 auto;
  margin-bottom: 10rem;
  max-width: 150rem;
  min-height: 100vh;
  max-width: 1024px;
}
.full {
  grid-column-start: 1;
  -ms-grid-column-span: 7;
  grid-column-end: span 7;
}
.intro {
  grid-column-start: 1;
  grid-column-end: span 5;
  margin-top: 6rem;
  font-size: 4.5rem;
}
.project-grid {
  grid-column-start: 1;
  grid-column-end: span 7;
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  grid-row-gap: 15rem;
  grid-column-gap: 2rem;
  margin: 1rem auto;
}
.project-grid a {
  -ms-grid-column-span: 2;
  grid-column: span 2;
  color: white;
  min-height: 56.25%;
}
.project-grid a h3 {
  font-size: 2.15rem;
  margin: 1.25rem 0;
}
.project-grid a p {
  font-size: 1.5rem;
  color: lightgrey;
}
.project-grid a img {
  margin-bottom: 0;
  -o-object-fit: cover;
  object-fit: cover;
  width: 100%;
  height: 100%;
}
main {
  padding: 3rem var(--padding);
}
footer {
  margin-top: 8rem;
  padding: 6rem var(--padding);
  display: flex;
  -webkit-box-pack: justify;
  justify-content: space-between;
  -webkit-box-align: center;
  align-items: center;
  flex-wrap: wrap;
  margin: 0 auto;
  max-width: 150rem;
  
}
footer > * {
  margin-top: var(--padding);
}
footer h2 {
  font-size: 4.5rem;
}
.button {
  padding: 2rem 3rem;
  font-size: 2.5rem;
  background: #8e8e8e;
  color: #1a1a1a;
}
.button:hover {
  -webkit-filter: brightness(1.5);
  filter: brightness(1.5);
}
.blog-grid {
  grid-column-start: 1;
  display: grid;
  grid-template-rows: repeat(3, fr);
  grid-row-gap: 15rem;
  grid-column-gap: 2rem;
  margin: 1rem auto;
  justify-content: left;
}
.articles {
  list-style: none;
}
.articles__item {
  display: flex;
  flex-wrap: wrap;
}
.articles__item__link {
  flex: 1;
  text-decoration: none;
  cursor: auto;
}
.articles__item__title {
  font-size: 2.15rem;
  margin: 1.25rem 0;
}
.articles__item__date {
  margin-right: 0.75rem;
  flex-basis: 7em;
}

.task {
  cursor:move;
  background-color:var(--white);
  padding:1rem;
  border-radius:8px;
  width:100%;
  box-shadow: rgba(99, 99, 99, 0.1) 0px 2px 8px 0px;
  margin-bottom:1rem;
  border:3px dashed transparent;
} 
.task__tag--copyright:hover {
  box-shadow: rgba(99, 99, 99, 0.3) 0px 2px 8px 0px;
  border-color:rgba(162,179,207,.2)!important;
}
   
.task__tag {
  font-size:12px;
  cursor:pointer;
  display: inline-block;
  padding: 0.3em 0.85em;
  text-transform: uppercase;
  border: 3px solid #28242f;
 

  transition: transform 0.2s;
  transition-timing-function: cubic-bezier(0.45, -0.85, 0.55, -0.45)
}

.task__tag:hover {
  transform: scale(1.1);
  background: linear-gradient(to right, #ff8a00, #da1b60);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.task__tags {
  list-style-type: none;
  margin: 0.5em 0.5em 1.5em 0.5em;
}

.task__tag--copyright {
  
  font-weight: 900;
}
 
.atitle {
  padding-top: 4rem;
}

.acontent {
  padding-top: 2rem;
}



pre {
  background: #222;
  border-bottom-left-radius: 10px;
  border-bottom-right-radius: 10px;
  color: #fff;
  padding: 2.5em;
  width: 100%;
  -webkit-font-smoothing: antialiased;
  margin-top: 2rem;
  margin-bottom: 2rem;
  overflow: scroll;
}

code {
  font: 'Source Code Pro';
  font-size: 1.2rem;  
}

h2 {
  margin-top: 2rem;
  margin-bottom: 2rem;
  font-size: 2.5rem;
}

p {
  font-size: 1.5rem;
}

li {
  font-size: 1.5rem;
}


@media (max-width: 4000px) {
  pre { 
    overflow: hidden ;
  }
}



@media (max-width: 960px) {
  :root {
    font-size: 9px;
  }
  .intro {
    grid-column-start: 1;
    -ms-grid-column-span: 7;
    grid-column-end: span 7;
  }
  .project-grid {
    grid-row-gap: 16rem;
  }
  .project-grid a h3 {
    font-size: 2.5rem;
    margin-bottom: 1.15rem;
  }
  .project-grid a {
    -ms-grid-column-span: 3;
    grid-column: span 3;
  }

  pre { 
    overflow: hidden ;
  }
}

@media (max-width: 700px) {
  :root {
    font-size: 8px;
    --padding: 2rem;
  }
  .project-grid {
    grid-row-gap: 24rem;
  }
  .project-grid a {
    -ms-grid-column-span: 6;
    grid-column: span 6;
  }
  .project-grid a h3 {
    font-size: 3rem;
    margin-top: 2rem;
  }
  .project-grid a p {
    font-size: 1.75rem;
  }
  .project-grid a img {
    width: 100vw;
    margin: auto calc(50% - 50vw);
  }
  pre { 
    overflow: scroll ;
  }
}
@media (min-width: 4000px) {
  :root {
    font-size: 40px;
  }
  
}
</style><meta charset="utf-8"><title>Blog</title></head><body><ul class="links" id="links"> <li><a class="who" href="https://discord.com/invite/2Uj6N5N" target="_blank">Discord</a></li><li><a class="blog" href="https://www.youtube.com/c/ViktorBřenekYT" target="_blank">Youtube</a></li><li><a class="source" href="https://github.com/viktorbrenek" target="_blank">Github</a></li></ul><menu><a class="name" href="#">Viktor Břenek</a><a class="name" href="../blog.html">Blog</a><a class="name" href="../index.html">Portfolio</a></menu><main class="gridblog"><h1 class="atitle">Elm Data Structures (2)</h1><div><span><ul class="task__tags"><li class="task__tag task__tag--copyright">Elm</li><li class="task__tag task__tag--copyright">Frontend development</li><li class="task__tag task__tag--copyright">Data structures</li><li class="task__tag task__tag--copyright">Record</li><li class="task__tag task__tag--copyright">Tuple</li></ul></span></div><p>After we have already covered the iterable data structures in the previous article, we will now work wth records and tuples, which can contain elements of different types. We will also have a look at how to access values using destructuring and get to know about type aliases …</p>
<div id="more"></div>
<p>Records and tuples can contain an arbitrary amount of elements – as opposed to <a href="/articles/elm-data-structures-list-array-set-dict.html">lists, arrays, sets and dictionaries</a> these elements do not have to be of the same data type. Because of that tuples and records are suited well for representing more complex element structures and objects. Before we will cover both of them in detail, let us first talk about <em>type aliases</em>, which can be used to further describe records and tuples and make them more expressive.</p>
<h3>Type Aliases</h3>
<p>The keyword <code>type</code> defines a new data type which did not exist before. Opposed to that <code>type alias</code> gives an extra name to an already existing type. It does not create a distinct data type but can be used to reference another type and give it a more expressive meaning for the context the data is used in. Type aliases can be defined on the root level of a program as well as in <code>let/in</code> expressions.</p>
<pre><code class="language-elm"><span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">Login</span> = <span class="hljs-type">String</span>
<span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">Age</span> = <span class="hljs-type">Int</span>
<span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">IsAdmin</span> = <span class="hljs-type">Bool</span>
</code></pre>
<p>They are used to further describe data structures. A type alias can be defined for basic data types and we will use them in the upcoming examples to give more meaning to our tuples and records.</p>
<h3>Tuples</h3>
<p>A tuple is an ordered collection of values, which can consist of two or more elements. In Elm tuples are created using the literal syntax of two surrounding parenthesis – the order as well as the count of values need to be the same for every tuple of the same type (defined by a type alias).</p>
<pre><code class="language-elm"><span class="hljs-comment">-- tuple without type definition</span>
<span class="hljs-title">coordinates</span> = (<span class="hljs-number">53.1201749</span>, <span class="hljs-number">8.5962037</span>)

<span class="hljs-comment">-- tuple with type definition</span>
<span class="hljs-title">area</span> : (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>)
<span class="hljs-title">area</span> = (<span class="hljs-number">42</span>, <span class="hljs-number">23</span>)

<span class="hljs-comment">-- tuple with type alias</span>
<span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">IsValid</span> = <span class="hljs-type">Bool</span>
<span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">Message</span> = <span class="hljs-type">String</span>
<span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">ValidationResult</span> = (<span class="hljs-type">IsValid</span>, <span class="hljs-type">Message</span>)

<span class="hljs-title">success</span> : <span class="hljs-type">ValidationResult</span>
<span class="hljs-title">success</span> = (<span class="hljs-type">True</span>, <span class="hljs-string">"All is good."</span>)

<span class="hljs-title">error</span> : <span class="hljs-type">ValidationResult</span>
<span class="hljs-title">error</span> = (<span class="hljs-type">False</span>, <span class="hljs-string">"Something went wrong."</span>)
</code></pre>
<p>Tuple are suitable for creating simple, short data structures – e.g. to return multiple values from a function. For accessing the values of a tuple with two values one can use the functions <code>first</code> and <code>second</code>, for tuples with three or more values one has to use destructuring.</p>
<h3>Destructuring</h3>
<p>With destructuring we can access the values of a tuple and directly assign these values to other variables. Using <code>_</code> one can define placeholders for values that will be ignored or skipped.</p>
<pre><code class="language-elm"><span class="hljs-title">coordinates</span> = (<span class="hljs-number">53.1201749</span>, <span class="hljs-number">8.5962037</span>)
(latitude, longitude) = coordinates

<span class="hljs-title">error</span> = (<span class="hljs-type">False</span>, <span class="hljs-string">"Something went wrong."</span>, [<span class="hljs-string">"username"</span>, <span class="hljs-string">"email"</span>])
(isValid, _, invalidFields) = error

<span class="hljs-comment">-- works even with nested tuples</span>
(a, (b, c, (d, e), _), _) = (<span class="hljs-number">1</span>, (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>), <span class="hljs-number">6</span>), <span class="hljs-number">7</span>)
</code></pre>
<p>For further <a href="http://www.lambdacat.com/road-to-elm-destructuring/">explanations for destructuring</a> see the LambdaCat article which also contains more examples and a comparison to destructuring in JavaScript.</p>
<h3>Records</h3>
<p>For more complex structures records are a better fit than tuples. Records consist of key-value pairs, which makes them similar similar to objects in JavaScript. They are created using the literal syntax of two surrounding curly braces and they can be described further using a type alias.</p>
<pre><code class="language-elm"><span class="hljs-comment">-- record without type definition</span>
<span class="hljs-title">coordinate</span> =
    { latitude = <span class="hljs-number">53.1201749</span>
    , longitude = <span class="hljs-number">8.5962037</span>
    }


<span class="hljs-comment">-- record with type definition</span>
<span class="hljs-title">area</span> : { width : <span class="hljs-type">Int</span>, height : <span class="hljs-type">Int</span> }
<span class="hljs-title">area</span> =
    { width = <span class="hljs-number">42</span>
    , height = <span class="hljs-number">23</span>
    }


<span class="hljs-comment">-- record with type definition via type alias</span>
<span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">User</span> =
    { login : <span class="hljs-type">String</span>
    , isAdmin : <span class="hljs-type">Bool</span>
    }


<span class="hljs-title">alice</span> : <span class="hljs-type">User</span>
<span class="hljs-title">alice</span> =
    { login = <span class="hljs-string">"alice"</span>
    , isAdmin = <span class="hljs-type">False</span>
    }


<span class="hljs-title">bob</span> : <span class="hljs-type">User</span>
<span class="hljs-title">bob</span> =
    { login = <span class="hljs-string">"bob"</span>
    , isAdmin = <span class="hljs-type">True</span>
    }
</code></pre>
<p>Values of a record can be accessed by means of these techniques:</p>
<ul>
<li>Directly with the dot syntax (similar as in JavaScript)</li>
<li>Using the standalone function with dot notation</li>
<li>Destructuring</li>
</ul>
<pre><code class="language-elm"><span class="hljs-title">alice</span>.isAdmin
<span class="hljs-comment">-- False : Bool</span>

.login bob
<span class="hljs-comment">-- "bob" : String</span>

<span class="hljs-type">List</span>.filter .isAdmin [alice, bob]
<span class="hljs-comment">-- [{ login = "bob", isAdmin = True }] : List User</span>

{ login, isAdmin } = alice
<span class="hljs-title">login</span>
<span class="hljs-comment">-- "alice" : String</span>
</code></pre>
<p>When using destructuring it is required to name the variable the value gets assigned to after the key of the according record value.</p>
<p>Using the standalone function with dot notation is a shortcut for the functionally equivalent option of using  an anonymous function: <code>(.isAdmin bob) == ((\u -&gt; u.isAdmin) bob)</code></p>
<p>Generally you do not have the options to access keys of a record that do not exist – as opposed to JavaScript objects. The compiler will give you an error for that, which is quite nice and a timesaver.</p>
<h4>Updating records</h4>
<p>To edit records one can create a new record based on an existing one. The name of the existing records and the fields you want to edit are separated by a <code>|</code> and one can change single or multiple values:</p>
<pre><code class="language-elm"><span class="hljs-title">aliceTheAdmin</span> =
    { alice | isAdmin = <span class="hljs-type">True</span> }


<span class="hljs-title">aliceTheMightyAdmin</span> =
    { alice
        | name = <span class="hljs-string">"mighty-alice"</span>
        , isAdmin = <span class="hljs-type">True</span>
    }
</code></pre>
<h4>Extensible records</h4>
<p>Last but not least there is also the concept of extensible records, which can be thought of as field mixins. An extensible record defines a type that has at least certain fields. This can be used for writing functions that take records which might not be of the same type but which share a common set of fields:</p>
<pre><code class="language-elm"><span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">Authorized</span> user =
    { user
        | canEdit : <span class="hljs-type">Bool</span>
        , canDelete : <span class="hljs-type">Bool</span>
    }


<span class="hljs-title">alice</span> : <span class="hljs-type">Authorized</span> (<span class="hljs-type">User</span>)
<span class="hljs-title">alice</span> =
    { login = <span class="hljs-string">"alice"</span>
    , isAdmin = <span class="hljs-type">False</span>
    , canEdit = <span class="hljs-type">True</span>
    , canDelete = <span class="hljs-type">False</span>
    }


<span class="hljs-title">bob</span> : <span class="hljs-type">Authorized</span> {}
<span class="hljs-title">bob</span> =
    { canEdit = <span class="hljs-type">True</span>
    , canDelete = <span class="hljs-type">True</span>
    }


<span class="hljs-title">allowedToEdit</span> : <span class="hljs-type">Authorized</span> a -&gt; <span class="hljs-type">Bool</span>
<span class="hljs-title">allowedToEdit</span> a =
    a.canEdit

<span class="hljs-title">allowedToEdit</span> alice
<span class="hljs-comment">-- True : Bool</span>

<span class="hljs-title">allowedToDelete</span> alice
<span class="hljs-comment">-- False : Bool</span>

<span class="hljs-title">allowedToDelete</span> bob
<span class="hljs-comment">-- True : Bool</span>
</code></pre>
<p>In this example <code>alice</code> is a <code>User</code> (as of the type defined in the earlier example), but <code>bob</code> is not. <code>bob</code> is just a simple record with the fields <code>canEdit</code> and <code>canDelete</code> that are defined in the extensible record type <code>Authorized</code>. Because both records are guaranteed to have those fields, we can use them in the same manner in the <code>allowedToEdit</code> and <code>allowedToDelete</code> functions – regardless of their exact type.</p>
<p>After we have looked at the iterable data structures as well as tuples and records the last article in the series about data structures in Elm will cover the <em>union type</em>. In contrast to the structures we have seen up to now a union type can be of multiple different data types.</p>
</main><footer></footer></body>