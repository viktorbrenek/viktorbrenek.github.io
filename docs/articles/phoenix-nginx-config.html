<!DOCTYPE html><head><title>Viktor Břenek</title><meta content="text/html;charset=utf-8" http-equiv="Content-Type"><meta content="utf-8" http-equiv="encoding"><meta name="author" content="Petr Břenek"><meta name="description" content="Osobní blog a portfolio"><meta property="og:image" content="http://viktorbrenek.github.io/assets/images/modely.png"><meta name="viewport" content="width=device-width,initial-scale=1.0"><link rel="stylesheet" href="../styles.css"><meta charset="utf-8"><title>Blog</title></head><body><ul class="links" id="links"> <li><a class="who" href="https://discord.com/invite/2Uj6N5N" target="_blank">Discord</a></li><li><a class="blog" href="https://www.youtube.com/c/ViktorBřenekYT" target="_blank">Youtube</a></li><li><a class="source" href="https://github.com/viktorbrenek" target="_blank">Github</a></li></ul><menu><a class="name" href="#">Viktor Břenek</a><a class="name" href="../blog.html">Blog</a><a class="name" href="../index.html">Portfolio</a></menu><main class="gridblog"><h1 class="atitle">Configuring NGINX for Phoenix applications</h1><div><span><ul class="task__tags"><li class="task__tag task__tag--copyright">Phoenix</li><li class="task__tag task__tag--copyright">Elixir</li><li class="task__tag task__tag--copyright">Nginx</li><li class="task__tag task__tag--copyright">Deployment</li><li class="task__tag task__tag--copyright">Gatling</li><li class="task__tag task__tag--copyright">Distillery</li><li class="task__tag task__tag--copyright">Tutorial</li><li class="task__tag task__tag--copyright">Ubuntu</li><li class="task__tag task__tag--copyright">Ubuntu 16</li><li class="task__tag task__tag--copyright">How To</li><li class="task__tag task__tag--copyright">Digital Ocean</li></ul></span></div><p>The previous article about <a href="/articles/phoenix-deployment-gatling-ubuntu-digital-ocean.html">deploying Phoenix with Gatling</a> did not go into details for a proper NGINX configuration.
Using NGINX as a front-end proxy for web applications is a pretty standard setup.
There are some things to keep in mind concerning Phoenix, SSL and asset delivery and this article sums up the details.</p>
<div id="more"></div>
<div class="note">
  <p><strong>TL;DR</strong> The goal of this article is to highlight some important config parts.
  We will not cover the basic setup of NGINX, but what goes into the webapps configuration options to make it secure, performant and easy to maintain:</p>
  <ul>
    <li>Extend a basic configuration with SSL</li>
    <li>Directives for delivering static asset via NGINX</li>
    <li>(specifics when deploying with Gatling)</li>
  </ul>
</div>
<h2>Basic configuration with websocket proxy directives</h2>
<p>Let’s start out with the basics:
This is the raw configuration file for Phoenix that <a href="https://github.com/hashrocket/gatling">Gatling</a> provides when we set up an app.
This article is not Gatling specific, but there were some questions about how to extend the initial setup which triggered me to write this up.
What you find here is general advise on how to setup NGINX for a Phoenix app – the Gatling specific parts are covered at the end.</p>
<pre><code class="language-nginx"><span class="hljs-section">server</span> {
  <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;
  <span class="hljs-attribute">server_name</span> myapp.com www.myapp.com;

  <span class="hljs-attribute">location</span> / {
    <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;
    <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;
    <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$http_host</span>;
    <span class="hljs-attribute">proxy_redirect</span> <span class="hljs-literal">off</span>;
    <span class="hljs-attribute">proxy_pass</span> http://localhost:34567;
    <span class="hljs-attribute">proxy_set_header</span> Upgrade <span class="hljs-variable">$http_upgrade</span>;
    <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">"upgrade"</span>;
  }
}
</code></pre>
<p>Basically this is just NGINX listening for requests that hit the configured domains on port 80 and proxying them to the Phoenix app that in this case runs on port 34567.</p>
<p>The important thing to note here are the last two <code>proxy_set_header</code> directives that upgrade the client-server connection, which is needed to use websockets and Phoenix channels.
For details see the offical blog on using <a href="https://www.NGINX.com/blog/websocket-NGINX/">NGINX as a WebSocket Proxy</a> and running <a href="http://www.phoenixframework.org/docs/serving-your-application-behind-a-proxy">Phoenix Behind a Proxy</a>.</p>
<h2>Securing the app with SSL</h2>
<p>One of the first steps I take when setting up a new webserver is securing the connections.
Nowadays this is pretty easy and does not involve any additional costs – thanks to the <a href="https://letsencrypt.org/">Let’s Encrypt</a> initiative.</p>
<p>This guide takes off from where you already got you certificates.
If you first need to obtain a SSL certificate, Digital Ocean has a great guide on <a href="https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-16-04?refcode=63eb025a3190">How To Secure Nginx with Let’s Encrypt</a>.
Their guide covers obtaining a SSL certificate via Let’s Encrypt and automating the renewal.
Most of the following configuration also resembles the general advise given in the mentioned guide.
<em>The Digital Ocean docs are really good by the way and also applicable for similar setups, not just for their boxes.</em></p>
<p>Enough of the praise, here comes the config …</p>
<pre><code class="language-nginx"><span class="hljs-comment"># extract Phoenix app upstream for better readability</span>
<span class="hljs-attribute">upstream</span> myapp {
  <span class="hljs-attribute">server</span> localhost:<span class="hljs-number">34567</span>;
}

<span class="hljs-comment"># hide server information</span>
<span class="hljs-section">http</span> {
  <span class="hljs-attribute">server_tokens</span> <span class="hljs-literal">off</span>;
}

<span class="hljs-comment"># redirect all http requests to https</span>
<span class="hljs-comment"># and also listen on IPv6 addresses</span>
<span class="hljs-section">server</span> {
  <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span> default_server;
  <span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">80</span> default_server;
  <span class="hljs-attribute">server_name</span> myapp.com www.myapp.com;

  <span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://<span class="hljs-variable">$server_name</span><span class="hljs-variable">$request_uri</span>;
}

<span class="hljs-comment"># the main server directive for ssl connections</span>
<span class="hljs-comment"># where we also use http2 (see asset delivery)</span>
<span class="hljs-section">server</span> {
  <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl http2 default_server;
  <span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">443</span> ssl http2 default_server;
  <span class="hljs-attribute">server_name</span> myapp.com www.myapp.com;

  <span class="hljs-comment"># paths to certificate and key provided by Let's Encrypt</span>
  <span class="hljs-attribute">ssl_certificate</span> /etc/letsencrypt/live/myapp.com/fullchain.pem;
  <span class="hljs-attribute">ssl_certificate_key</span> /etc/letsencrypt/live/myapp.com/privkey.pem;

  <span class="hljs-comment"># SSL settings that currently offer good results in the SSL check</span>
  <span class="hljs-comment"># and have a reasonable backwards-compatibility, taken from</span>
  <span class="hljs-comment"># - https://cipherli.st/</span>
  <span class="hljs-comment"># - https://raymii.org/s/tutorials/Strong_SSL_Security_On_nginx.html</span>
  <span class="hljs-attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>;
  <span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;
  <span class="hljs-attribute">ssl_ciphers</span> <span class="hljs-string">"EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH"</span>;
  <span class="hljs-attribute">ssl_ecdh_curve</span> secp384r1;
  <span class="hljs-attribute">ssl_session_cache</span> shared:SSL:<span class="hljs-number">10m</span>;
  <span class="hljs-attribute">ssl_session_tickets</span> <span class="hljs-literal">off</span>;
  <span class="hljs-attribute">ssl_stapling</span> <span class="hljs-literal">on</span>;
  <span class="hljs-attribute">ssl_stapling_verify</span> <span class="hljs-literal">on</span>;
  <span class="hljs-attribute">ssl_dhparam</span> /etc/ssl/certs/dhparam.pem;

  <span class="hljs-comment"># security enhancements</span>
  <span class="hljs-attribute">add_header</span> Strict-Transport-Security <span class="hljs-string">"max-age=63072000; includeSubdomains"</span>;
  <span class="hljs-attribute">add_header</span> X-Frame-Options DENY;
  <span class="hljs-attribute">add_header</span> X-Content-Type-Options nosniff;

  <span class="hljs-comment"># Let's Encrypt keeps its files here</span>
  <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ /.well-known</span> {
    <span class="hljs-attribute">root</span> /var/www/html;
    <span class="hljs-attribute">allow</span> all;
  }

  <span class="hljs-comment"># besides referencing the extracted upstream this stays the same</span>
  <span class="hljs-attribute">location</span> / {
    <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;
    <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;
    <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$http_host</span>;
    <span class="hljs-attribute">proxy_redirect</span> <span class="hljs-literal">off</span>;
    <span class="hljs-attribute">proxy_pass</span> http://myapp;
    <span class="hljs-attribute">proxy_set_header</span> Upgrade <span class="hljs-variable">$http_upgrade</span>;
    <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">"upgrade"</span>;
  }
}
</code></pre>
<p>Noteworthy parts of this rather long config change:</p>
<ul>
<li>Personally I prefer to extract the upstream and have it at the top of the config file.
But this is totally optional and you can leave it as it was.</li>
<li>We integrated the SSL certificates provided by Let’s Encrypt and are redirecting all unencrypted traffic to the secured connection.</li>
<li>Depending on your needs you might want to change some of the SSL settings:
The ones shown here offer a good compromise between an A+ result in the <a href="https://www.ssllabs.com/ssltest/index.html">SSL check</a>
and a reasonable backwards-compatibility. (Support for IE &gt;= 10 and Android &gt;= 4)</li>
</ul>
<p>Beyond that we have also enabled <code>http2</code> support via the <code>listen</code> directive.
This gives us benefits like <a href="https://http2.github.io/faq/#what-are-the-key-differences-to-http1x">connection multiplexing and low-latency transport</a>, which brings us to the next point …</p>
<h2>Static asset delivery</h2>
<p>The <code>mix phoenix.digest</code> task already takes care of preparing the assets for efficient delivery.
It adds a unique hash to the filename, which is based on the file content.
This gives us static files that are cacheable by the client forever:
Whenever the content changes a new filename will be generated which forces the client to download the new file.</p>
<p>The task also outputs a gzip compressed version of the file.
The webserver can directly serve the compressed version without having to generate it itself.
NGINX could handle gzipping the assets via the <a href="https://www.digitalocean.com/community/tutorials/how-to-add-the-gzip-module-to-nginx-on-ubuntu-16-04?refcode=63eb025a3190">gzip module</a>, but we do not have to take care of that.</p>
<p>By default the assets get served by the Phoenix app.
This is not much of a problem server performance wise, but I encountered these two problems that prevent efficient file delivery:</p>
<ul>
<li>The <code>Expires</code> header for browser-caching does not get set, forcing the client to (re)download the file with every request.</li>
<li>Even though the gzipped file is present, the uncompressed file gets sent. This means wasted traffic for the client as well as the server.</li>
</ul>
<p>Maybe it is just me not finding the correct settings:
I tried configuring <a href="https://github.com/elixir-lang/plug/blob/master/lib/plug/static.ex"><code>Plug.Static</code></a> with the <code>gzip</code> and <code>headers</code> options, but I did not succeed – feedback and pointers in the right direction are appreciated!</p>
<p>So let’s turn to our trusted webserver to deliver the static files efficiently.
We need to add another <code>location</code> directive inside the existing one:
This new <code>location</code> matches all types of static files we want to deliver with NGINX.
We suppress the <code>ETag</code> header as we will be setting the maximum <code>Expires</code> date, which instructs the client to cache the file almost forever.</p>
<p>The <code>root</code> path needs to be set and will depend on your deployment scenario and tools.
It is the path where the static files are stored or copied to after the <code>mix phoenix.digest</code> task has run.
Depending on how you deploy (e.g. using Distillery releases) there are different ways to get the files to this path, see this <a href="https://elixirforum.com/t/phoenix-behind-a-nginx/1313/6">Elixir Forum post on using Phoenix behind a proxy</a> for details.</p>
<pre><code class="language-nginx"><span class="hljs-section">server</span> {
  <span class="hljs-comment"># …</span>
  <span class="hljs-attribute">location</span> / {
    <span class="hljs-comment"># this part stays the same, no changes, just as a reference</span>
    <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;
    <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;
    <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$http_host</span>;
    <span class="hljs-attribute">proxy_redirect</span> <span class="hljs-literal">off</span>;
    <span class="hljs-attribute">proxy_pass</span> http://myapp;
    <span class="hljs-attribute">proxy_set_header</span> Upgrade <span class="hljs-variable">$http_upgrade</span>;
    <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">"upgrade"</span>;

    <span class="hljs-comment"># asset delivery using NGINX</span>
    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~* ^.+\.(css|cur|gif|gz|ico|jpg|jpeg|js|png|svg|woff|woff2)$</span> {
      <span class="hljs-attribute">root</span> /path/to/myapp/priv/static;
      <span class="hljs-attribute">etag</span> <span class="hljs-literal">off</span>;
      <span class="hljs-attribute">expires</span> max;
      <span class="hljs-attribute">add_header</span> Cache-Control public;
    }
  }
}
</code></pre>
<p>When you are deploying with Gatling you could set this to the <code>priv/static</code> directory inside the folder the project is build in, i.e <code>/home/deploy/myapp/priv/static</code>.</p>
<h2>Applying the changes</h2>
<p>The last step is to reload the NGINX configuration so that the changes above get applied:</p>
<pre><code class="language-bash">sudo service nginx reload
</code></pre>
<p>That’s it, your NGINX should be serving a secure and performant webapp 🎉</p>
<p>In case you are deploying with Gatling, the last part is relevant to you too – otherwise you can stop reading here and enjoy your day!</p>
<h2>Extending the Gatling NGINX config</h2>
<p>There isn’t anything specific to the NGINX config when you are deploying with Gatling.
Except the fact that setting up a project gives you a minimalistic config file there is no magic involved:
Once Gatling has deployed the config file it won’t touch it anymore.
Same goes with the port, which is the only reason Gatling provides the config – so that you do not have to enter the port manually.</p>
<p>Having said this you can easily adapt you config following these steps:</p>
<ul>
<li>Get the current nginx.conf (deployed by Gatling)</li>
<li>Change it, leaving the upstream port as it is</li>
<li>Overwrite the existing nginx.conf</li>
<li>Reload the NGINX configuration (see above)</li>
</ul>
<p>There isn’t anything more to it.
You can then check the <code>nginx.conf</code> into version control and also delete the <code>domains</code> file.
Right now there is no way to <a href="https://github.com/hashrocket/gatling/issues/10">start out with a custom nginx.conf</a>.
That might change in the future and maybe also offer a way to automatically update the config on deployment – stay tuned!</p>
</main><footer></footer></body>